import pygame
import random



class Maze:

    OUTSIDE = -1
    EMPTY = 0
    WALL = 1
    START = 2
    END = 3


    def __init__(self, rows=21, cols=21):
        # Dimensions of the maze
        self.rows = rows
        self.cols = cols

        # Generate a blank maze with all blocks
        self.maze = [[self.WALL for _ in range(rows)] for _ in range(cols)]

        # Set the start and end points - 1, 1 and cols - 2, rows - 2 to be inside the maze
        self.start_x = 1
        self.start_y = 1    
        self.end_x = cols - 2
        self.end_y = rows - 2

        # Stack for recursive backtracking maze generation algorithm - to be used in generate maze
        self.stack = [(self.start_x, self.start_y)]

        # Directions that we can travel in - up, left, down, right
        self.directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        # Path generated by the A* search algorithm
        self.path = []



    # Print the maze in the console - for debugging purposes
    def print_maze(self):
        for row in self.maze:
            print(" ".join(["#" if cell == 1 else " " for cell in row]))



    # Generate the maze using the recursive backtracking algorithm
    """
    The intuition of this algorithm is to carve out tunnels in the maze by moving in a random direction until a wall is hit.

    We know a wall has been hit if there is an empty cell two steps away in the direction we are moving.

    If there is a wall ahead, and also a wall two steps away, we carve out the tunnel by setting the cell in front and the cell two steps away as empty.

    The stack will be exhausted when there are no more possible tunnels to carve, signifying the completion of the maze.
    """
    def generate_maze(self):
        # Set the start point as empty
        self.maze[self.start_x][self.start_y] = self.EMPTY

        # Generate the maze, stop when stack is empty as there are no more tunnels to carve out
        while self.stack:
            # Get the position at the top of the stack, but do not remove it 
            current_x, current_y = self.stack[-1]

            # Get the neighbors of the current cell which can be carved out - this means there is a wall ahead and a wall two steps away
            neighbors = []
            for dx, dy in self.directions:
                nx, ny = current_x + dx * 2, current_y + dy * 2
                # Ensure the 2-step-away neighbor is inside the maze and is a wall
                if 0 <= nx < self.cols and 0 <= ny < self.rows and self.maze[nx][ny] == 1:
                    neighbors.append((nx, ny, dx, dy))

            # If there are neighbors, carve out a tunnel by setting the current cell and the 2-step-away cell as empty and move to the 2-step-away cell
            if neighbors:
                next_x, next_y, dx, dy = random.choice(neighbors)
                self.maze[current_x + dx][current_y + dy] = self.EMPTY
                self.maze[next_x][next_y] = self.EMPTY
                self.stack.append((next_x, next_y))
            # If there are no neighbors, pop the current cell from the stack as no tunnels can be carved out from that position
            else:
                self.stack.pop()

        # Set the start and end points of the maze
        self.maze[1][1] = self.START
        self.maze[self.cols - 2][self.rows - 2] = self.END

        # print(self.print_maze())


        return self.maze

